<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>Scala 简明教程 - 滴滴 MIS 团队技术博客</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="../../assets/css/bulma.min.css"><link rel="stylesheet" href="../../assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="../../index.html">滴滴 MIS 团队技术博客</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="../../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../../2019/kafka/index.html" class="breadcrumb-item">Kafka</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../../2019/kafka/2019-06-24-scala-simple-lesson.html" class="breadcrumb-item">Scala 简明教程</a></div><h1 class="article-title">Scala 简明教程</h1><div class="article"><h1 id="table-of-contents">Table of Contents <a class="markdownIt-Anchor" href="#table-of-contents">#</a></h1><ul><li><a href="#scala-%E7%AE%80%E4%BB%8B">Scala 简介</a><ul><li><a href="#%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE">安装与配置</a><ul><li><a href="#%E5%AE%89%E8%A3%85-java">安装 Java</a></li><li><a href="#%E5%AE%89%E8%A3%85-scala">安装 Scala</a></li><li><a href="#%E5%AE%89%E8%A3%85-sbt">安装 sbt</a></li></ul></li><li><a href="#hello-world">Hello World</a><ul><li><a href="#%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F">交互模式</a></li><li><a href="#%E7%BC%96%E8%AF%91%E6%A8%A1%E5%BC%8F">编译模式</a></li><li><a href="#%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%BC%8F">构建模式</a></li></ul></li></ul></li><li><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">基本语法</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a><ul><li><a href="#%E6%95%B4%E6%95%B0">整数</a></li><li><a href="#%E6%B5%AE%E7%82%B9%E6%95%B0">浮点数</a></li><li><a href="#%E5%AD%97%E7%AC%A6">字符</a></li><li><a href="#%E5%B8%83%E5%B0%94">布尔</a></li><li><a href="#%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B">其它类型</a></li><li><a href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F">变量与常量</a></li></ul></li><li><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91">流程控制逻辑</a><ul><li><a href="#%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6">条件控制</a></li><li><a href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6">循环控制</a></li><li><a href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E7%9A%84-break-%E5%92%8C-continue">循环控制的 break 和 continue</a></li></ul></li></ul></li><li><a href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1">类和对象</a><ul><li><a href="#%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90">一个例子</a></li><li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a><ul><li><a href="#%E4%B8%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">主构造函数</a></li><li><a href="#%E8%BE%85%E5%8A%A9%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">辅助构造函数</a></li><li><a href="#singleton-objects">singleton objects</a></li></ul></li><li><a href="#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1-companion-object">伴生对象 Companion Object</a></li><li><a href="#%E7%BB%A7%E6%89%BF">继承</a><ul><li><a href="#override">override</a></li><li><a href="#%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90-1">一个例子</a></li></ul></li></ul></li><li><a href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">模式匹配</a><ul><li><a href="#%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90%E6%95%B4%E5%9E%8B%E6%95%B0%E5%80%BC%E5%8C%B9%E9%85%8D%E6%B8%A9%E5%BA%A6%E5%88%A4%E6%96%AD">简单例子（整型数值匹配、温度判断）</a></li><li><a href="#case-class">case class</a></li><li><a href="#apply">apply</a></li><li><a href="#unapply">unapply</a></li></ul></li><li><a href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-akka">并发编程 Akka</a><ul><li><a href="#akka-hello-world">Akka Hello World</a></li><li><a href="#akka-quickstart-with-scala">Akka Quickstart with Scala</a><ul><li><a href="#%E4%B8%8B%E8%BD%BD">下载</a></li></ul></li><li><a href="#%E9%85%8D%E7%BD%AE%E5%8F%8A%E8%BF%90%E8%A1%8C">配置及运行</a><ul><li><a href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB">代码解读</a></li><li><a href="#%E6%80%9D%E8%80%83">思考</a></li></ul></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">参考文献</a></li></ul><h1 id="scala-简介">Scala 简介 <a class="markdownIt-Anchor" href="#scala-简介">#</a></h1><p>Scala 集成了面向对象编程和函数式编程语言的各种特性。Scala 的静态类型帮助减少复杂系统中的 bug，并且支持 JVM 和 JavaScript 运行环境，同时还提供丰富的类库可供使用。</p><p>Scala 的官网地址为 <a href="https://www.scala-lang.org/" target="_blank" rel="noopener">https://www.scala-lang.org</a></p><h2 id="安装与配置">安装与配置 <a class="markdownIt-Anchor" href="#安装与配置">#</a></h2><p>Scala 运行环境依赖于 JVM，所以要先安装 Java。之后再安装 Scala，最后安装 sbt。</p><h3 id="安装-java">安装 Java <a class="markdownIt-Anchor" href="#安装-java">#</a></h3><p>在 oracle 官网下载 JavaSE 1.5 以上的版本。下载地址如下：</p><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p><p>这里我选择 1.8 版本，根据自己的操作系统选择合适的下载包。</p><figure><img src="https://blog.text.wiki/images/2019/jdk_18.png" alt="JDk 1.8"><figcaption>JDk 1.8</figcaption></figure><p>设置环境变量的教程在这里：<a href="https://www.runoob.com/java/java-environment-setup.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-environment-setup.html</a></p><p>设置完成后，我们可以在终端查看 <code>java</code> 和 <code>javac</code> 命令:</p><pre class="hljs"><code>$ java -version
java version &quot;1.8.0_181&quot;
Java(TM) SE Runtime Environment (build 1.8.0_181-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)
$ javac -version
javac 1.8.0_181
</code></pre><h3 id="安装-scala">安装 Scala <a class="markdownIt-Anchor" href="#安装-scala">#</a></h3><p>Scala 的下载地址为 <a href="https://www.scala-lang.org/download/" target="_blank" rel="noopener">https://www.scala-lang.org/download/</a> 。可以根据自己的操作系统选择合适的下载包。</p><p>如果操作系统为 Windows，可以查找 msi 的安装文件。</p><p>如果操作系统为 Mac，可以使用 Homebrew 来安装：</p><pre class="hljs"><code>brew update
brew install scala
</code></pre><p>如果操作系统为 Ubuntu，直接用 <code>apt-get install scala</code> 来进行安装。</p><p>安装完成后，可以运行如下命令来查看 <code>scala</code> 命令：</p><pre class="hljs"><code>$ scala -version
Scala code runner version 2.13.0 -- Copyright 2002-2019, LAMP/EPFL and Lightbend, Inc.
</code></pre><h3 id="安装-sbt">安装 sbt <a class="markdownIt-Anchor" href="#安装-sbt">#</a></h3><p>sbt 的全称为 Simple Build Tool，用于管理 Scala 项目的依赖并进行构建，其地址就像 Maven 之于 Java。其下载地址为 <a href="https://www.scala-sbt.org/download.html" target="_blank" rel="noopener">https://www.scala-sbt.org/download.html</a>。</p><h2 id="hello-world">Hello World <a class="markdownIt-Anchor" href="#hello-world">#</a></h2><p>我们演示三种输出 <code>Hello World</code> 的方式。</p><h3 id="交互模式">交互模式 <a class="markdownIt-Anchor" href="#交互模式">#</a></h3><p>在命令行输入 <code>scala</code> 命令，进入交互模式。</p><pre class="hljs"><code><span class="hljs-meta">$</span><span class="bash"> scala</span>
Welcome to Scala 2.13.0 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_181).
Type in expressions for evaluation. Or try :help.
<span class="hljs-meta">
scala&gt;</span><span class="bash"> println(<span class="hljs-string">"Hello World"</span>);</span>
Hello World
</code></pre><h3 id="编译模式">编译模式 <a class="markdownIt-Anchor" href="#编译模式">#</a></h3><p>创建一个文件 HelloWorldDemo.scala，文件内容如下：</p><pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">HelloWorldDemo</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]):<span class="hljs-type">Unit</span> = {
      println(<span class="hljs-string">"Hello World"</span>);
   }
}
</code></pre><p>运行编译及运行命令：</p><pre class="hljs"><code><span class="hljs-meta">$</span><span class="bash"> scalac HelloWorldDemo.scala</span>
<span class="hljs-meta">$</span><span class="bash"> scala HelloWorldDemo</span>
Hello World
</code></pre><h3 id="构建模式">构建模式 <a class="markdownIt-Anchor" href="#构建模式">#</a></h3><p>可以使用 sbt 来构建。如编译模式的文件为例，我们将其放到 helloworld 目录里。确保该目录只有一个文件。输入 sbt 命令，然后用 run 命令运行。</p><pre class="hljs"><code><span class="hljs-meta">$</span><span class="bash"> sbt</span>
sbt:helloworld&gt; run
[info] Updating ...
[info] Done updating.
[info] Compiling 1 Scala source to /Users/didi/code/scala/helloworld/target/scala-2.12/classes ...
[info] Non-compiled module 'compiler-bridge_2.12' for Scala 2.12.7. Compiling...
[info]   Compilation completed in 8.672s.
[info] Done compiling.
[info] Packaging /Users/didi/code/scala/helloworld/target/scala-2.12/helloworld_2.12-0.1.0-SNAPSHOT.jar ...
[info] Done packaging.
[info] Running HelloWorldDemo 
Hello World
[success] Total time: 18 s, completed 2019-6-25 15:19:19
sbt:helloworld&gt; run
[info] Running HelloWorldDemo 
Hello World
[success] Total time: 0 s, completed 2019-6-25 15:19:23
</code></pre><p>可以看到，第一次 run 时，需要进行编译，耗时 18 s。第二次 run 时，不需再编译即可运行，耗时可以忽略不计。</p><h1 id="基本语法">基本语法 <a class="markdownIt-Anchor" href="#基本语法">#</a></h1><h2 id="基本概念">基本概念 <a class="markdownIt-Anchor" href="#基本概念">#</a></h2><ul><li>类：外部事物的抽象，具有方法和属性。</li><li>对象：对象是类的具体实例；类是对象的抽象。</li><li>方法：方法是类的某个行为动作。一个类可以包含多个方法。</li><li>属性：类的若干属性，又称为字段。</li><li>语句：语句是执行代码的单元。如果一行只有一个语句，那么结尾不需要加<code>;</code>分号。如果一行之内有多个语句的话，需要加分号。</li><li>注释：支持多行注释 <code>/* */</code> 和单行注释 <code>//</code>。</li><li>包：使用 <code>package</code> 定义包，类似于命名空间。</li><li>引用：使用 <code>import</code> 引用包。注意 Scala 的包引用可以出现在任何地方，而不只是文件的顶部。</li><li>标识符：标识符可以由字母和下划线开头，后面可以连接数字、字母和下划线。区分大小写。</li><li>类名：类名采用驼峰写法，每个单词首字母大写。</li><li>方法名：方法名称的第一个字母用小写，其余每个单词的第一个字母大写。</li><li>程序文件名：程序文件名称和对象名称要完全匹配。虽然新版本不再要求，但为了保证代码能通过旧版本编译器，还是保持一致较好。</li><li>程序入口：程序入口为 main 方法。</li></ul><h2 id="数据类型">数据类型 <a class="markdownIt-Anchor" href="#数据类型">#</a></h2><p>Scala 的数据类型分为以下几类：</p><h3 id="整数">整数 <a class="markdownIt-Anchor" href="#整数">#</a></h3><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>Byte</td><td>8位有符号补码整数。数值区间为 -128 到 127</td></tr><tr><td>Short</td><td>16位有符号补码整数。数值区间为 -32768 到 32767</td></tr><tr><td>Int</td><td>32位有符号补码整数。数值区间为 -2147483648 到 2147483647</td></tr><tr><td>Long</td><td>64位有符号补码整数。数值区间为 -9223372036854775808 到 9223372036854775807</td></tr></tbody></table><h3 id="浮点数">浮点数 <a class="markdownIt-Anchor" href="#浮点数">#</a></h3><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>Float</td><td>32 位, IEEE 754 标准的单精度浮点数</td></tr><tr><td>Double</td><td>64 位 IEEE 754 标准的双精度浮点数</td></tr></tbody></table><h3 id="字符">字符 <a class="markdownIt-Anchor" href="#字符">#</a></h3><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>Char</td><td>16位无符号Unicode字符, 区间值为 U+0000 到 U+FFFF</td></tr><tr><td>String</td><td>字符序列</td></tr></tbody></table><h3 id="布尔">布尔 <a class="markdownIt-Anchor" href="#布尔">#</a></h3><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>Boolean</td><td>true或false</td></tr></tbody></table><h3 id="其它类型">其它类型 <a class="markdownIt-Anchor" href="#其它类型">#</a></h3><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>Unit</td><td>表示无值，和其他语言中void等同。用作不返回任何结果的方法的结果类型。Unit只有一个实例值，写成()。</td></tr><tr><td>Null</td><td>null 或空引用</td></tr><tr><td>Nothing</td><td>Nothing类型在Scala的类层级的最低端；它是任何其他类型的子类型。</td></tr><tr><td>Any</td><td>Any是所有其他类的超类</td></tr><tr><td>AnyRef</td><td>AnyRef类是Scala里所有引用类(reference class)的基类</td></tr></tbody></table><h3 id="变量与常量">变量与常量 <a class="markdownIt-Anchor" href="#变量与常量">#</a></h3><p>变量在程序运行过程中，其值可能发生改变，采用 <code>var</code> 声明变量；</p><p>常量在程序运行过程中，其值不会发生改变，采用 <code>val</code> 声明常量。</p><p>声明变量和常量的语法如下：</p><pre class="hljs"><code>var VariableName : DataType [=  Initial Value]

或

val VariableName : DataType [=  Initial Value]
</code></pre><p>另外 DataType 是可选的。如果不指定数据类型，编译器会自动根据初始值推断出数据类型。</p><h2 id="流程控制逻辑">流程控制逻辑 <a class="markdownIt-Anchor" href="#流程控制逻辑">#</a></h2><p>Scala 的流程控制主要包括条件控制和循环控制。</p><h3 id="条件控制">条件控制 <a class="markdownIt-Anchor" href="#条件控制">#</a></h3><p>其使用方法和其它语言类似，示例如下：</p><pre class="hljs"><code><span class="hljs-keyword">if</span>(布尔表达式 <span class="hljs-number">1</span>){
   <span class="hljs-comment">// 如果布尔表达式 1 为 true 则执行该语句块</span>
}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(布尔表达式 <span class="hljs-number">2</span>){
   <span class="hljs-comment">// 如果布尔表达式 2 为 true 则执行该语句块</span>
}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(布尔表达式 <span class="hljs-number">3</span>){
   <span class="hljs-comment">// 如果布尔表达式 3 为 true 则执行该语句块</span>
}<span class="hljs-keyword">else</span> {
   <span class="hljs-comment">// 如果以上条件都为 false 执行该语句块</span>
}
</code></pre><h3 id="循环控制">循环控制 <a class="markdownIt-Anchor" href="#循环控制">#</a></h3><p>循环支持三种循环类型：while 循环、do while 循环和 for 循环。</p><ol><li><p>while 循环</p><pre class="hljs"><code>while(condition)
{
   //语句块
}
</code></pre></li><li><p>do while循环</p><pre class="hljs"><code>do {
   //语句块
} while( condition );
</code></pre></li><li><p>for 循环</p><pre class="hljs"><code>for( var x &lt;- Range ){
   //语句块
}
</code></pre></li></ol><h3 id="循环控制的-break-和-continue">循环控制的 break 和 continue <a class="markdownIt-Anchor" href="#循环控制的-break-和-continue">#</a></h3><p>Scala 的 break 的语法和其它语言不同，它完全是基于类的一种实现。</p><p>文件：BreakDemo.scala</p><pre class="hljs"><code><span class="hljs-keyword">import</span> scala.util.control.<span class="hljs-type">Breaks</span>;
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">BreakDemo</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]) {
      <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">val</span> numList = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);

      <span class="hljs-keyword">val</span> loop = <span class="hljs-keyword">new</span> <span class="hljs-type">Breaks</span>;
      loop.breakable {
         <span class="hljs-keyword">for</span>( i &lt;- numList){
            println( <span class="hljs-string">"第"</span> + i + <span class="hljs-string">"次"</span> );
            <span class="hljs-keyword">if</span>( i == <span class="hljs-number">3</span> ){
               loop.<span class="hljs-keyword">break</span>;
            }
         }
      }
      println( <span class="hljs-string">"事不过三"</span> );
   }
}
</code></pre><p>输出结果：</p><pre class="hljs"><code>第1次
第2次
第3次
事不过三
</code></pre><p>遗憾的是，Scala 里并没有 continue 的语法，即跳过本次循环。但想一下 continue 的实质是什么？跳过满足特定条件的循环中的元素，即过滤掉某些元素，让其不参与循环。Scala 提供了循环过滤的机制。</p><p>我们看一下示例。</p><p>文件：ForFilterDemo.scala</p><pre class="hljs"><code><span class="hljs-keyword">import</span> java.util.<span class="hljs-type">Random</span>;
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">ForFilterDemo</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]) {
        <span class="hljs-keyword">var</span> r = <span class="hljs-keyword">new</span> <span class="hljs-type">Random</span>()
        <span class="hljs-keyword">var</span> rand = r.nextInt(<span class="hljs-number">100</span>)
        <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span>(i &lt;- <span class="hljs-number">0</span> to <span class="hljs-number">10</span>
            <span class="hljs-keyword">if</span> rand % <span class="hljs-number">2</span> == <span class="hljs-number">0</span><span class="hljs-comment">//只保留所有的偶数</span>
        ){
            println(rand)
            rand = r.nextInt(<span class="hljs-number">100</span>)
        }
      
   }
}
</code></pre><p>输出结果（每次都不相同）：</p><pre class="hljs"><code>6
90
12
</code></pre><p>我们循环 10 次，每次取一个 100 以内的随机数，要求只保留偶数，所有的奇数都过滤掉。实现上可以用 for + if 的循环过滤机制来实现。</p><h1 id="类和对象">类和对象 <a class="markdownIt-Anchor" href="#类和对象">#</a></h1><p>Scala 类的特征有如下几个：</p><ul><li><p>单继承</p></li><li><p>无 static 静态属性和方法，但提供了单例对象（singleton objects）的概念</p></li><li><p>支持抽象类和抽象方法</p></li><li><p>支持重载（override）</p></li></ul><h2 id="一个例子">一个例子 <a class="markdownIt-Anchor" href="#一个例子">#</a></h2><p>首先看一个类的示例。Point 类有两个属性 x 和 y，并有一个方法 move。</p><p>文件：PointDemo.scala</p><pre class="hljs"><code><span class="hljs-keyword">import</span> java.io._

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>(<span class="hljs-params">val xc: <span class="hljs-type">Int</span>, val yc: <span class="hljs-type">Int</span></span>) </span>{
   <span class="hljs-keyword">var</span> x: <span class="hljs-type">Int</span> = xc
   <span class="hljs-keyword">var</span> y: <span class="hljs-type">Int</span> = yc
   
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move</span></span>(dx: <span class="hljs-type">Int</span>, dy: <span class="hljs-type">Int</span>) {
      x = x + dx
      y = y + dy
      println (<span class="hljs-string">"Point x location : "</span> + x);
      println (<span class="hljs-string">"Point y location : "</span> + y);
   }
}

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">PointDemo</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]) {
      <span class="hljs-keyword">val</span> pt = <span class="hljs-keyword">new</span> <span class="hljs-type">Point</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);

      <span class="hljs-comment">// Move to a new location</span>
      pt.move(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);
   }
}
</code></pre><p>运行命令如下：</p><pre class="hljs"><code><span class="hljs-meta">&gt;</span><span class="bash"> scalac PointDemo.scala</span>
<span class="hljs-meta">&gt;</span><span class="bash"> scala PointDemo</span>
Point x location : 20
Point y location : 30
</code></pre><p>在这个例子里，需要注意的是，如果文件中定义了不止一个类，则要使用 <code>scalac</code> 进行编译后再运行。</p><p>这个例子还可以学到构造函数和 singleton objects 的知识，我们分述如下。</p><h2 id="构造函数">构造函数 <a class="markdownIt-Anchor" href="#构造函数">#</a></h2><p>Scala 的构造函数分为主构造函数和辅助构造函数。</p><h3 id="主构造函数">主构造函数 <a class="markdownIt-Anchor" href="#主构造函数">#</a></h3><p>在上例中，定义 Point 类的语句如下：</p><pre class="hljs"><code>class Point(val xc: Int, val yc: Int) 
</code></pre><p>其中 <code>xc</code>、<code>yc</code> 为构造函数的参数。那么其函数的定义在哪里呢？</p><p>在类的主体里，除了 <code>def</code> 定义的函数之外，其余部分都是主构造函数。</p><h3 id="辅助构造函数">辅助构造函数 <a class="markdownIt-Anchor" href="#辅助构造函数">#</a></h3><p>辅助构造函数用于创造不同类型、不同数目参数的构造函数。定义方法如下：</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>(){
	<span class="hljs-comment">//function body</span>
}
</code></pre><p>我们改造一下<code>PointDemo.scala</code>文件，来演示主构造函数和辅助构造函数。</p><p>文件：PointDemo2.scala</p><pre class="hljs"><code><span class="hljs-keyword">import</span> java.io._

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>(<span class="hljs-params">val xc: <span class="hljs-type">Int</span>, val yc: <span class="hljs-type">Int</span></span>) </span>{
   <span class="hljs-keyword">var</span> x: <span class="hljs-type">Int</span> = xc
   <span class="hljs-keyword">var</span> y: <span class="hljs-type">Int</span> = yc
   
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>(){<span class="hljs-comment">//if no params,set (0,0)</span>
       <span class="hljs-keyword">this</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)
       println(<span class="hljs-string">"Auxiliary constructor"</span>)
   }
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move</span></span>(dx: <span class="hljs-type">Int</span>, dy: <span class="hljs-type">Int</span>) {
      x = x + dx
      y = y + dy
      println (<span class="hljs-string">"Point x location : "</span> + x);
      println (<span class="hljs-string">"Point y location : "</span> + y);
   }
   println(<span class="hljs-string">"Main Constructor"</span>);<span class="hljs-comment">//this is main constructor too</span>
}

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">PointDemo2</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]) {
      <span class="hljs-keyword">val</span> pt1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Point</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);
      <span class="hljs-comment">// Move to a new location</span>
      pt1.move(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);

      <span class="hljs-keyword">val</span> pt2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Point</span>();
      <span class="hljs-comment">// Move to a new location</span>
      pt2.move(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);
   }
}
</code></pre><p>输出结果：</p><pre class="hljs"><code>Main Constructor
Point x location : 20
Point y location : 30
Main Constructor
Auxiliary constructor
Point x location : 10
Point y location : 10
</code></pre><p>我们看以下问题：</p><ol><li>主构造函数和辅助构造函数有什么区别？</li></ol><p>答案是没有区别。当我们实例化一个类时，编译器会自动匹配参数类型和参数个数相符的构造的函数。</p><ol start="2"><li>能否将主构造函数和辅助构造函数的参数完全一致？</li></ol><p>答案是不能。我们定义辅助构造函数如下：</p><pre class="hljs"><code><span class="hljs-comment">//    demo for same main and auxiliary constructors  </span>
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>(xc: <span class="hljs-type">Int</span>, yc: <span class="hljs-type">Int</span>){
          <span class="hljs-keyword">this</span>(xc,yc)
          println(<span class="hljs-string">"Auxiliary constructor"</span>)
      }
</code></pre><p>结果编译通不过。</p><h3 id="singleton-objects">singleton objects <a class="markdownIt-Anchor" href="#singleton-objects">#</a></h3><p><code>singleton object</code> 有如下特征：</p><ul><li><p><code>singleton object</code> 里的方法是全局可见的</p></li><li><p>不能为 <code>singleton object</code> 创建实例</p></li></ul><ul><li><code>singleton object</code> 的主构造函数不接收参数</li><li><code>singleton object</code> 可以继承 <code>class</code> 和 <code>traits</code></li><li><code>singleton object</code>始终存在 <code>main</code> 方法</li><li>不需要创建实例即可调用 <code>singleton object</code> 的方法</li></ul><p>我们查看一下实例。</p><p>文件：SingletonDemo.scala</p><pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Exampleofsingleton</span> </span>
{ 
      
    <span class="hljs-comment">// Varaibles of singleton object </span>
    <span class="hljs-keyword">var</span> str1 = <span class="hljs-string">"Welcome ! MIS"</span>; 
    <span class="hljs-keyword">var</span> str2 = <span class="hljs-string">"This is Scala language tutorial"</span>; 
      
    <span class="hljs-comment">// Method of singleton object </span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span></span>() 
    { 
        println(<span class="hljs-string">"Called By Display Method"</span>)
        println(str1); 
        println(str2); 
    } 
} 
  
<span class="hljs-comment">// Singleton object with named as Main </span>
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">SingletonDemo</span>  </span>
{ 
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]) 
    { 
          
        <span class="hljs-comment">// Calling method of singleton object  </span>
        <span class="hljs-type">Exampleofsingleton</span>.display(); 

        println(<span class="hljs-string">"Called By Property"</span>)
        println(<span class="hljs-type">Exampleofsingleton</span>.str1);
        println(<span class="hljs-type">Exampleofsingleton</span>.str2);
    } 
} 
</code></pre><p>输出结果如下：</p><pre class="hljs"><code>Called By Display Method
Welcome ! MIS
This is Scala language tutorial
Called By Property
Welcome ! MIS
This is Scala language tutorial
</code></pre><h2 id="伴生对象-companion-object">伴生对象 Companion Object <a class="markdownIt-Anchor" href="#伴生对象-companion-object">#</a></h2><p>我们经常会遇到这样的场景：定义一个类，实现常见的功能；再定义一个类来调用以完成特定的任务。这样带来命名问题，这有时也是让开发者头疼的一件事情。</p><p>Scala 的伴生对象完美解决了这个问题。我们先看下例子：</p><p>文件：SingletonDemo.scala</p><pre class="hljs"><code><span class="hljs-comment">// Companion class </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompanionDemo</span> </span>
{ 
      
    <span class="hljs-comment">// Variables of Companion class </span>
    <span class="hljs-keyword">var</span> str1 = <span class="hljs-string">"MIS"</span>; 
    <span class="hljs-keyword">var</span> str2 = <span class="hljs-string">"Tutorial of Companion object"</span>; 
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> str3 = <span class="hljs-string">"Hello MIS"</span>
      
    <span class="hljs-comment">// Method of Companion class </span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span></span>() 
    { 
        println(str1); 
        println(str2); 
    } 

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mis</span></span>()
    {
        println(<span class="hljs-string">"In mis method"</span>)
        println(str3)
    }
} 
  
<span class="hljs-comment">// Companion object </span>
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">CompanionDemo</span></span>
{ 
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>])  
    { 
        <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-type">CompanionDemo</span>(); 
        obj.show(); 
        println(obj.str3);
        obj.mis();
    } 
}   
</code></pre><p>输出结果：</p><pre class="hljs"><code>MIS
Tutorial of Companion object
Hello MIS
In mis method
Hello MIS
</code></pre><p>可以看到同时存在 <code>class CompanionDemo</code> 和 <code>object CompanionDemo</code>。</p><p>伴生对象的特点如下：</p><ul><li><code>companion object</code> 和 <code>companion class</code> 的名称必须完全一致</li><li><code>companion object</code> 必须和 <code>companion class</code> 定义在同一个文件中</li><li><code>companion object</code> 可以访问 <code>companion class</code> 的私有属性和私有方法</li></ul><p>伴生对象除了解决命名问题外，还可以对外提供接口，方便调用。</p><h2 id="继承">继承 <a class="markdownIt-Anchor" href="#继承">#</a></h2><p>Scala 是单继承的语言，子类只有一个父类。</p><p>###抽象类和抽象方法</p><p>定义一个抽象类，需要使用 <code>abstract</code> 关键字。例如：</p><pre class="hljs"><code><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>(<span class="hljs-params">iname:<span class="hljs-type">String</span></span>)</span>
{
   <span class="hljs-comment">//class body</span>
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span> </span>
}
</code></pre><p>定义抽象方法，执行保持方法的函数体为空即可。</p><p>子类继承抽象父类，必须实现父类的所有的抽象方法。</p><h3 id="override">override <a class="markdownIt-Anchor" href="#override">#</a></h3><p><code>override</code> 关键字有以下特点：</p><ul><li><p>子类重写父类的抽象方法，不需要加 <code>override</code> 关键字。</p></li><li><p>子类重新父类的普通方法，需要加 <code>override</code> 关键字。</p></li><li><p>只有主构造函数才可以往父类的构造函数里写参数。</p></li></ul><h3 id="一个例子-1">一个例子 <a class="markdownIt-Anchor" href="#一个例子-1">#</a></h3><p>我们看一个演示继承的例子。</p><p>文件：InheritDemo.scala</p><pre class="hljs"><code><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>(<span class="hljs-params">iname:<span class="hljs-type">String</span></span>)</span>
{
    <span class="hljs-keyword">val</span> name:<span class="hljs-type">String</span> = iname;
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span> </span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move</span></span>(){
        println(<span class="hljs-string">"All Animals Can Move"</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span></span>(){
        println(<span class="hljs-string">"Hello "</span>+name)
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>(<span class="hljs-params">iname:<span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span>(<span class="hljs-params">iname:<span class="hljs-type">String</span></span>) </span>
{
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span></span>(){
        println(<span class="hljs-string">"Dog Eats Bones"</span>);
    }
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move</span></span>(){
        println(<span class="hljs-string">"Dog is An Animal, So Dog can move"</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span></span>(msg:<span class="hljs-type">String</span>){
        println(<span class="hljs-string">"Hello "</span>+name+<span class="hljs-string">" "</span>+msg)
    }
}

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">InheritDemo</span></span>
{
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>])  
    { 
       <span class="hljs-keyword">val</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-type">Dog</span>(<span class="hljs-string">"Teddy"</span>);
       dog.eat();
       dog.move();
       dog.display(<span class="hljs-string">"Welcome!"</span>)
    } 
}
</code></pre><p>输出结果：</p><pre class="hljs"><code>Dog Eats Bones
Dog is An Animal, So Dog can move
Hello Teddy Welcome!
</code></pre><p><code>Dog</code> 类的 <code>display</code> 方法为什么没有加 <code>override</code> ？</p><p>答案是 <code>Dog</code> 类的 <code>display</code> 方法的参数和 <code>Animal</code> 类的 <code>display</code> 方法不同，不属于重写，所以不需要加 <code>override</code> 。</p><h1 id="模式匹配">模式匹配 <a class="markdownIt-Anchor" href="#模式匹配">#</a></h1><p>Scala 使用 <code>case</code> 关键字实现多条件逻辑匹配的功能。每个条件是一个备选项，称为模式。每个备选项包含一个模式和一到多个表达式。语法如下：</p><pre class="hljs"><code>case 模式 =&gt; 语句;
</code></pre><p>我们看几个例子，学习模式匹配。</p><h2 id="简单例子（整型数值匹配、温度判断）">简单例子（整型数值匹配、温度判断） <a class="markdownIt-Anchor" href="#简单例子（整型数值匹配、温度判断）">#</a></h2><p>文件：Temperature.scala</p><pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Temperature</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]) {
        println(display(<span class="hljs-number">37</span>))
        println(display(<span class="hljs-number">100</span>))
        println(display(<span class="hljs-number">50</span>))
   }
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span></span>(x: <span class="hljs-type">Int</span>): <span class="hljs-type">String</span> = x <span class="hljs-keyword">match</span> {
      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> =&gt; <span class="hljs-string">"freezing point"</span> 
      <span class="hljs-keyword">case</span> <span class="hljs-number">100</span> =&gt; <span class="hljs-string">"boiling point"</span> 
      <span class="hljs-keyword">case</span> x <span class="hljs-keyword">if</span>(x &gt;= <span class="hljs-number">36.5</span> &amp;&amp; x &lt;= <span class="hljs-number">37.5</span>) =&gt; <span class="hljs-string">"body point"</span>
      <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">"other point"</span>
   }
}
</code></pre><p>输出结果：</p><pre class="hljs"><code>body point
boiling point
other point
</code></pre><p>match 表达式通过以代码编写的先后次序尝试每个模式来完成计算，只要发现有一个匹配的case，剩下的case不会继续匹配。</p><h2 id="case-class">case class <a class="markdownIt-Anchor" href="#case-class">#</a></h2><p>文件：CaseClassDemo.scala</p><pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">CaseClassDemo</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]) {
       <span class="hljs-keyword">val</span> alice = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(<span class="hljs-string">"Alice"</span>, <span class="hljs-number">25</span>)
    	 <span class="hljs-keyword">val</span> bob = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(<span class="hljs-string">"Bob"</span>, <span class="hljs-number">32</span>)
       <span class="hljs-keyword">val</span> charlie = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(<span class="hljs-string">"Charlie"</span>, <span class="hljs-number">32</span>)
   
    <span class="hljs-keyword">for</span> (person &lt;- <span class="hljs-type">List</span>(alice, bob, charlie)) {
        person <span class="hljs-keyword">match</span> {
            <span class="hljs-keyword">case</span> <span class="hljs-type">Person</span>(<span class="hljs-string">"Alice"</span>, <span class="hljs-number">25</span>) =&gt; println(<span class="hljs-string">"Hi Alice!"</span>)
            <span class="hljs-keyword">case</span> <span class="hljs-type">Person</span>(<span class="hljs-string">"Bob"</span>, <span class="hljs-number">32</span>) =&gt; println(<span class="hljs-string">"Hi Bob!"</span>)
            <span class="hljs-keyword">case</span> <span class="hljs-type">Person</span>(name, age) =&gt;
               println(<span class="hljs-string">"Age: "</span> + age + <span class="hljs-string">" year, name: "</span> + name + <span class="hljs-string">"?"</span>)
         }
      }
   }
   <span class="hljs-comment">// 样例类</span>
   <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span></span>)</span>
}
</code></pre><p>输出结果：</p><pre class="hljs"><code>Hi Alice!
Hi Bob!
Age: 32 year, name: Charlie?
</code></pre><p>在声明样例类时，下面的过程自动发生了：</p><ul><li>构造器的每个参数都成为val，除非显式被声明为var，但是并不推荐这么做；</li><li>在伴生对象中提供了apply方法，所以可以不使用new关键字就可构建对象；</li><li>提供unapply方法使模式匹配可以工作；</li><li>生成toString、equals、hashCode和copy方法，除非显示给出这些方法的定义。</li></ul><h2 id="apply">apply <a class="markdownIt-Anchor" href="#apply">#</a></h2><p>将对象以函数的方式进行调用时，scala会隐式地将调用改为在该对象上调用apply方法。例如XXX(“hello”)实际调用的是XXX.apply(“hello”), 因此apply方法又被称为注入方法。apply方法常用于创建类实例的工厂方法。示例如下：</p><pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Greeting</span></span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(name: <span class="hljs-type">String</span>) = <span class="hljs-string">"Hello "</span> + name
}

<span class="hljs-type">Greeting</span>.apply(“<span class="hljs-type">Lucy</span>”) <span class="hljs-comment">//与下面的调用等价 </span>
<span class="hljs-type">Greeting</span>(“<span class="hljs-type">Lucy</span>”) <span class="hljs-comment">//结果为 Hello Lucy</span>

</code></pre><h2 id="unapply">unapply <a class="markdownIt-Anchor" href="#unapply">#</a></h2><p>与 apply 相对的是 unapply 方法，它的用法与 apply 类似，但其作用是用来抽取部分参数，它也称为抽取方法，主要用于模式匹配时抽取某些参数 case XXX(str) =&gt; println(str)</p><h1 id="并发编程-akka">并发编程 Akka <a class="markdownIt-Anchor" href="#并发编程-akka">#</a></h1><p>从 Scala 的 2.11.0 版本开始，Scala 的 Actors 库已经过时了。早在 Scala 2.10.0 的时候，默认的 actor 库即是 Akka。所以我们重点讲述 Akka。</p><p>Akka 是构建高并发、分布式、弹性消息驱动的 Java 和 Scala 应用的工具集合。官网地址是https://akka.io/ 。</p><h2 id="akka-hello-world">Akka Hello World <a class="markdownIt-Anchor" href="#akka-hello-world">#</a></h2><p>示例代码我已经放到 github 上了，地址为 <a href="https://github.com/spetacular/scala-simple-lesson%E3%80%82" target="_blank" rel="noopener">https://github.com/spetacular/scala-simple-lesson。</a></p><p>下载代码后，用命令行 <code>cd akkademo</code> 进入示例代码目录。</p><p>依次运行 <code>stb</code> 、<code>compile</code>、<code>run</code>，可以看到类似于如下输出：</p><pre class="hljs"><code><span class="hljs-meta">$</span><span class="bash"> sbt</span>
[info] Loading project definition from /Users/didi/Documents/GitHub/scala-simple-lesson/akkademo/project
[info] Loading settings for project akkademo from build.sbt ...
[info] Set current project to akka-demo (in build file:/Users/didi/Documents/GitHub/scala-simple-lesson/akkademo/)
[info] sbt server started at local:///Users/didi/.sbt/1.0/server/bc7cb24c19aa2ba1ff53/sock
sbt:akka-demo&gt; compile
[info] Updating ...
[info] Done updating.
[info] Compiling 1 Scala source to /Users/didi/Documents/GitHub/scala-simple-lesson/akkademo/target/scala-2.12/classes ...
[info] Done compiling.
[success] Total time: 6 s, completed 2019-6-25 17:57:00
sbt:akka-demo&gt; run
[info] Packaging /Users/didi/Documents/GitHub/scala-simple-lesson/akkademo/target/scala-2.12/akka-demo_2.12-1.0.jar ...
[info] Done packaging.
[info] Running com.example.AkkaDemo 
fine thank you
huh?
</code></pre><p>我们看下代码：</p><pre class="hljs"><code><span class="hljs-number">1</span>  <span class="hljs-keyword">package</span> com.example;
<span class="hljs-number">2</span>  <span class="hljs-keyword">import</span> akka.actor.{<span class="hljs-type">Actor</span>,<span class="hljs-type">ActorSystem</span>,<span class="hljs-type">Props</span>}
<span class="hljs-number">3</span>  
<span class="hljs-number">4</span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloActor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Actor</span> </span>{
<span class="hljs-number">5</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">receive</span> </span>= {
<span class="hljs-number">6</span>      <span class="hljs-keyword">case</span> <span class="hljs-string">"how are you"</span> =&gt; println(<span class="hljs-string">"fine thank you"</span>)
<span class="hljs-number">7</span>      <span class="hljs-keyword">case</span> _       =&gt; println(<span class="hljs-string">"huh?"</span>)
<span class="hljs-number">8</span>    }
<span class="hljs-number">9</span>  }
<span class="hljs-number">10</span>  
<span class="hljs-number">11</span>  <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">AkkaDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>{
<span class="hljs-number">12</span>    <span class="hljs-keyword">val</span> system = <span class="hljs-type">ActorSystem</span>(<span class="hljs-string">"HelloSystem"</span>)
<span class="hljs-number">13</span>    <span class="hljs-comment">// default Actor constructor</span>
<span class="hljs-number">14</span>    <span class="hljs-keyword">val</span> helloActor = system.actorOf(<span class="hljs-type">Props</span>[<span class="hljs-type">HelloActor</span>], name = <span class="hljs-string">"helloactor"</span>)
<span class="hljs-number">15</span>    helloActor ! <span class="hljs-string">"how are you"</span>
<span class="hljs-number">16</span>    helloActor ! <span class="hljs-string">"Bonjour"</span>
<span class="hljs-number">17</span>  }
</code></pre><p>我们先看下调用示例图：</p><figure><img src="https://blog.text.wiki/images/2019/akka_demo_1.png" alt="akka demo调用示例"><figcaption>akka demo调用示例</figcaption></figure><p>第 4 至 9 行，定义了 <code>HelloActor</code> 的类。<code>HelloActor</code> 继承在 <code>Actor</code> 类，实现了 <code>receive</code> 方法。该方法根据传递过来的字符串，做出不同的动作。</p><p>第 11 行，<code>AkkaDemo</code> 继承了 <code>App</code> 类，作为<code>main class</code>，是程序执行的入口。</p><p>第 12 行，定义了一个 <code>ActorSystem</code>，这是所有 <code>Actor</code> 的容器。</p><p>第 14 行，定义了一个 <code>Actor</code>。<code>Actor</code> 是一种类似于线程、goroutine的一个事物，是执行调度的一个单位。在创建 <code>helloActor</code> 的时候，并没有用 <code>new</code> 关键字来实例化，而是用 <code>actorOf</code> 来创建一个 <code>Actor</code> 的引用。<code>actorOf</code> 接收两个参数：配置类 <code>Props</code> 和名称。这种方式的优点是在分布式系统上，调用方不用关心实质的 <code>Actor</code> 在哪台机器上。</p><p>第 15、16行，将<code>&quot;how are you&quot;</code>和<code>&quot;Bonjour&quot;</code>的消息传递给 <code>HelloActor</code>。</p><p>这个例子演示了 akka 的 AkkaSystem、Actor、消息传递是如何交互的。但这个例子，仍然是串行处理的。我们将在下面的例子中，演示并行编程。</p><h2 id="akka-quickstart-with-scala">Akka Quickstart with Scala <a class="markdownIt-Anchor" href="#akka-quickstart-with-scala">#</a></h2><p>这个例子来自 Akka 官方示例，网址为 <a href="https://developer.lightbend.com/guides/akka-quickstart-scala/index.html" target="_blank" rel="noopener">Akka Quickstart with Scala</a> 。</p><h3 id="下载">下载 <a class="markdownIt-Anchor" href="#下载">#</a></h3><p>下载方法有两种：</p><ol><li>在官网页面 <a href="https://developer.lightbend.com/start/?group=akka&amp;project=akka-quickstart-scala" target="_blank" rel="noopener">Lightbend Tech Hub</a> 点击 <code>CREATE A PROJECT FOR ME</code></li><li>嫌速度慢可以下载 <a href="https://github.com/spetacular/scala-simple-lesson" target="_blank" rel="noopener">Scala Simple Lesson</a> ，解压后 <strong>akka-quickstart-scala</strong> 目录即是示例代码。</li></ol><h2 id="配置及运行">配置及运行 <a class="markdownIt-Anchor" href="#配置及运行">#</a></h2><p>解压后的代码，构建脚本可能没有运行权限，需要用 <code>chmod</code> 命令添加可运行权限。</p><pre class="hljs"><code><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> akka-quickstart-scala</span>
<span class="hljs-meta">$</span><span class="bash"> chmod u+x ./sbt</span>
<span class="hljs-meta">$</span><span class="bash"> chmod u+x ./sbt-dist/bin/sbt</span>
</code></pre><p>然后输入 <code>./sbt</code> 。这时会下载依赖的包，可能会持续一段时间。</p><p>然后在 stb 输入提示符下，输入 <code>reStart</code> 来启动示例。类似的输出如下：</p><pre class="hljs"><code>sbt:akka-quickstart-scala&gt; reStart
[info] Updating ...
[info] Done updating.
[info] Compiling 1 Scala source to /Users/didi/Documents/GitHub/scala-simple-lesson/akka-quickstart-scala/target/scala-2.12/classes ...
[info] Done compiling.
[info] Application akka-quickstart-scala not yet started
[info] Starting application akka-quickstart-scala in the background ...
akka-quickstart-scala Starting com.example.AkkaQuickstart.main()
[success] Total time: 5 s, completed 2019-6-25 20:16:03
sbt:akka-quickstart-scala&gt; akka-quickstart-scala [INFO] [06/25/2019 20:16:04.502] [helloAkka-akka.actor.default-dispatcher-5] [akka://helloAkka/user/printerActor] Greeting received (from Actor[akka://helloAkka/user/helloGreeter#266661191]): Hello, Scala
akka-quickstart-scala [INFO] [06/25/2019 20:16:04.502] [helloAkka-akka.actor.default-dispatcher-5] [akka://helloAkka/user/printerActor] Greeting received (from Actor[akka://helloAkka/user/howdyGreeter#1265860474]): Howdy, Akka
akka-quickstart-scala [INFO] [06/25/2019 20:16:04.502] [helloAkka-akka.actor.default-dispatcher-5] [akka://helloAkka/user/printerActor] Greeting received (from Actor[akka://helloAkka/user/howdyGreeter#1265860474]): Howdy, Lightbend
akka-quickstart-scala [INFO] [06/25/2019 20:16:04.502] [helloAkka-akka.actor.default-dispatcher-5] [akka://helloAkka/user/printerActor] Greeting received (from Actor[akka://helloAkka/user/goodDayGreeter#1928998630]): Good day, Play
</code></pre><h3 id="代码解读">代码解读 <a class="markdownIt-Anchor" href="#代码解读">#</a></h3><p>完整代码如下：</p><pre class="hljs"><code><span class="hljs-number">1</span>  <span class="hljs-comment">//#full-example</span>
<span class="hljs-number">2</span>  <span class="hljs-keyword">package</span> com.example
<span class="hljs-number">3</span>  
<span class="hljs-number">4</span>  <span class="hljs-keyword">import</span> akka.actor.{ <span class="hljs-type">Actor</span>, <span class="hljs-type">ActorLogging</span>, <span class="hljs-type">ActorRef</span>, <span class="hljs-type">ActorSystem</span>, <span class="hljs-type">Props</span> }
<span class="hljs-number">5</span>  
<span class="hljs-number">6</span>  <span class="hljs-comment">//#greeter-companion</span>
<span class="hljs-number">7</span>  <span class="hljs-comment">//#greeter-messages</span>
<span class="hljs-number">8</span>  <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Greeter</span> </span>{
<span class="hljs-number">9</span>    <span class="hljs-comment">//#greeter-messages</span>
<span class="hljs-number">10</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">props</span></span>(message: <span class="hljs-type">String</span>, printerActor: <span class="hljs-type">ActorRef</span>): <span class="hljs-type">Props</span> = <span class="hljs-type">Props</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Greeter</span>(message, printerActor))
<span class="hljs-number">11</span>    <span class="hljs-comment">//#greeter-messages</span>
<span class="hljs-number">12</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WhoToGreet</span>(<span class="hljs-params">who: <span class="hljs-type">String</span></span>)</span>
<span class="hljs-number">13</span>    <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Greet</span></span>
<span class="hljs-number">14</span>  }
<span class="hljs-number">15</span>  <span class="hljs-comment">//#greeter-messages</span>
<span class="hljs-number">16</span>  <span class="hljs-comment">//#greeter-companion</span>
<span class="hljs-number">17</span>  
<span class="hljs-number">18</span>  <span class="hljs-comment">//#greeter-actor</span>
<span class="hljs-number">19</span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeter</span>(<span class="hljs-params">message: <span class="hljs-type">String</span>, printerActor: <span class="hljs-type">ActorRef</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Actor</span> </span>{
<span class="hljs-number">20</span>    <span class="hljs-keyword">import</span> <span class="hljs-type">Greeter</span>._
<span class="hljs-number">21</span>    <span class="hljs-keyword">import</span> <span class="hljs-type">Printer</span>._
<span class="hljs-number">22</span>  
<span class="hljs-number">23</span>    <span class="hljs-keyword">var</span> greeting = <span class="hljs-string">""</span>
<span class="hljs-number">24</span>  
<span class="hljs-number">25</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">receive</span> </span>= {
<span class="hljs-number">26</span>      <span class="hljs-keyword">case</span> <span class="hljs-type">WhoToGreet</span>(who) =&gt;
<span class="hljs-number">27</span>        greeting = message + <span class="hljs-string">", "</span> + who
<span class="hljs-number">28</span>      <span class="hljs-keyword">case</span> <span class="hljs-type">Greet</span>           =&gt;
<span class="hljs-number">29</span>        <span class="hljs-comment">//#greeter-send-message</span>
<span class="hljs-number">30</span>        printerActor ! <span class="hljs-type">Greeting</span>(greeting)
<span class="hljs-number">31</span>        <span class="hljs-comment">//#greeter-send-message</span>
<span class="hljs-number">32</span>    }
<span class="hljs-number">33</span>  }
<span class="hljs-number">34</span>  <span class="hljs-comment">//#greeter-actor</span>
<span class="hljs-number">35</span>  
<span class="hljs-number">36</span>  <span class="hljs-comment">//#printer-companion</span>
<span class="hljs-number">37</span>  <span class="hljs-comment">//#printer-messages</span>
<span class="hljs-number">38</span>  <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Printer</span> </span>{
<span class="hljs-number">39</span>    <span class="hljs-comment">//#printer-messages</span>
<span class="hljs-number">40</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">props</span></span>: <span class="hljs-type">Props</span> = <span class="hljs-type">Props</span>[<span class="hljs-type">Printer</span>]
<span class="hljs-number">41</span>    <span class="hljs-comment">//#printer-messages</span>
<span class="hljs-number">42</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">greeting: <span class="hljs-type">String</span></span>)</span>
<span class="hljs-number">43</span>  }
<span class="hljs-number">44</span>  <span class="hljs-comment">//#printer-messages</span>
<span class="hljs-number">45</span>  <span class="hljs-comment">//#printer-companion</span>
<span class="hljs-number">46</span>  
<span class="hljs-number">47</span>  <span class="hljs-comment">//#printer-actor</span>
<span class="hljs-number">48</span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Printer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Actor</span> <span class="hljs-keyword">with</span> <span class="hljs-title">ActorLogging</span> </span>{
<span class="hljs-number">49</span>    <span class="hljs-keyword">import</span> <span class="hljs-type">Printer</span>._
<span class="hljs-number">50</span>  
<span class="hljs-number">51</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">receive</span> </span>= {
<span class="hljs-number">52</span>      <span class="hljs-keyword">case</span> <span class="hljs-type">Greeting</span>(greeting) =&gt;
<span class="hljs-number">53</span>        log.info(<span class="hljs-string">"Greeting received (from "</span> + sender() + <span class="hljs-string">"): "</span> + greeting)
<span class="hljs-number">54</span>    }
<span class="hljs-number">55</span>  }
<span class="hljs-number">56</span>  <span class="hljs-comment">//#printer-actor</span>
<span class="hljs-number">57</span>  
<span class="hljs-number">58</span>  <span class="hljs-comment">//#main-class</span>
<span class="hljs-number">59</span>  <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">AkkaQuickstart</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>{
<span class="hljs-number">60</span>    <span class="hljs-keyword">import</span> <span class="hljs-type">Greeter</span>._
<span class="hljs-number">61</span>  
<span class="hljs-number">62</span>    <span class="hljs-comment">// Create the 'helloAkka' actor system</span>
<span class="hljs-number">63</span>    <span class="hljs-keyword">val</span> system: <span class="hljs-type">ActorSystem</span> = <span class="hljs-type">ActorSystem</span>(<span class="hljs-string">"helloAkka"</span>)
<span class="hljs-number">64</span>  
<span class="hljs-number">65</span>    <span class="hljs-comment">//#create-actors</span>
<span class="hljs-number">66</span>    <span class="hljs-comment">// Create the printer actor</span>
<span class="hljs-number">67</span>    <span class="hljs-keyword">val</span> printer: <span class="hljs-type">ActorRef</span> = system.actorOf(<span class="hljs-type">Printer</span>.props, <span class="hljs-string">"printerActor"</span>)
<span class="hljs-number">68</span>  
<span class="hljs-number">69</span>    <span class="hljs-comment">// Create the 'greeter' actors</span>
<span class="hljs-number">70</span>    <span class="hljs-keyword">val</span> howdyGreeter: <span class="hljs-type">ActorRef</span> =
<span class="hljs-number">71</span>      system.actorOf(<span class="hljs-type">Greeter</span>.props(<span class="hljs-string">"Howdy"</span>, printer), <span class="hljs-string">"howdyGreeter"</span>)
<span class="hljs-number">72</span>    <span class="hljs-keyword">val</span> helloGreeter: <span class="hljs-type">ActorRef</span> =
<span class="hljs-number">73</span>      system.actorOf(<span class="hljs-type">Greeter</span>.props(<span class="hljs-string">"Hello"</span>, printer), <span class="hljs-string">"helloGreeter"</span>)
<span class="hljs-number">74</span>    <span class="hljs-keyword">val</span> goodDayGreeter: <span class="hljs-type">ActorRef</span> =
<span class="hljs-number">75</span>      system.actorOf(<span class="hljs-type">Greeter</span>.props(<span class="hljs-string">"Good day"</span>, printer), <span class="hljs-string">"goodDayGreeter"</span>)
<span class="hljs-number">76</span>    <span class="hljs-comment">//#create-actors</span>
<span class="hljs-number">77</span>  
<span class="hljs-number">78</span>    <span class="hljs-comment">//#main-send-messages</span>
<span class="hljs-number">79</span>    howdyGreeter ! <span class="hljs-type">WhoToGreet</span>(<span class="hljs-string">"Akka"</span>)
<span class="hljs-number">80</span>    howdyGreeter ! <span class="hljs-type">Greet</span>
<span class="hljs-number">81</span>    
<span class="hljs-number">82</span>    howdyGreeter ! <span class="hljs-type">WhoToGreet</span>(<span class="hljs-string">"Lightbend"</span>)
<span class="hljs-number">83</span>    howdyGreeter ! <span class="hljs-type">Greet</span>
<span class="hljs-number">84</span>    
<span class="hljs-number">85</span>    helloGreeter ! <span class="hljs-type">WhoToGreet</span>(<span class="hljs-string">"Scala"</span>)
<span class="hljs-number">86</span>    helloGreeter ! <span class="hljs-type">Greet</span>
<span class="hljs-number">87</span>  
<span class="hljs-number">88</span>    goodDayGreeter ! <span class="hljs-type">WhoToGreet</span>(<span class="hljs-string">"Play"</span>)
<span class="hljs-number">89</span>    goodDayGreeter ! <span class="hljs-type">Greet</span>
<span class="hljs-number">90</span>    
<span class="hljs-number">91</span>    <span class="hljs-comment">//#main-send-messages</span>
<span class="hljs-number">92</span>  }
<span class="hljs-number">93</span>  <span class="hljs-comment">//#main-class</span>
<span class="hljs-number">94</span>  <span class="hljs-comment">//#full-example</span>
</code></pre><p>我们先直观地看下这个文件的大体框架，如下图所示。</p><figure><img src="https://blog.text.wiki/images/2019/hello-akka-architecture.png" alt="akka demo 架构图"><figcaption>akka demo 架构图</figcaption></figure><p>首先 main 类创建了ActorSystem 容器，然后创建了三个 Greeter Actor 实例和一个 Printer Actor 实例。</p><figure><img src="https://blog.text.wikihttps://blog.text.wiki/images/2019/hello-akka-messages.png" alt="akka消息传递"><figcaption>akka消息传递</figcaption></figure><p>main 类首先将消息传递给三个 Greeter Actor，然后三个 Greeter Actor 分别再将消息传递给 Printer Actor，并由 Printer Actor 将消息打印出来。</p><p>下面是详细解读。</p><p>第 6 至 34 行，定义了 <code>Greeter</code> 的伴友类和伴友对象。注意 <code>Greeter</code> 是一个 <code>Actor</code>，其 <code>receive</code> 方法定义在第 25 至 32 行。</p><p>第 12 行定义了 <code>WhoToGreet</code> 的样例类：<code>final case class WhoToGreet(who: String)</code> 。</p><p>第 13 行定义了 <code>Greet</code> 的样例类：<code>case object Greet</code> 。</p><p><code>Greeter</code>、<code>WhoToGreet</code>、<code>Greet</code> 的关系是怎样的呢？</p><p><code>Greeter</code> 意思为礼仪人员。它接收的 <code>case class</code> 是 <code>WhoToGreet</code> 和 <code>Greet</code>。就是说礼仪人员有两个用途：一是组织根据人员组装合适的礼貌用语(WhoToGreet），另一个是将拼好的礼貌用语用嘴巴(Printer)说出去(Greet)。</p><p>第 36 至 56 行定义了 <code>Printer</code> 的伴友类和伴友对象。</p><p>第 41 行定义了 <code>Greeting</code> 样例类：<code>case class Greeting(greeting: String)</code> 。</p><p>第 51 至 54 行定义了 <code>Printer</code> 的 <code>receive</code> 方法。它接收 <code>Greeting</code>，并将 <code>greeting</code> 内容打印出来。</p><p>第 58 至 94 行为入口方法。</p><p>第 63 行定义了名为 <code>helloAkka</code> 的 Actor System。</p><p>第 69 至 76 行创建了三个 Greeter 的实例：<code>howdyGreeter</code>、<code>helloGreeter</code>、<code>goodDayGreeter</code>。他们会说不同的礼貌用语。</p><p>第 78 至 91 行调用 Actor 进行并发处理。我们以第一个调用为例，看一下处理流程。</p><pre class="hljs"><code>howdyGreeter ! <span class="hljs-type">WhoToGreet</span>(<span class="hljs-string">"Akka"</span>)
howdyGreeter ! <span class="hljs-type">Greet</span>
</code></pre><p>首先将 <code>WhoToGreet(&quot;Akka&quot;)</code> 的消息传递给 <code>howdyGreeter</code>，这时会激活如下语句：</p><pre class="hljs"><code><span class="hljs-number">26</span>      <span class="hljs-keyword">case</span> <span class="hljs-type">WhoToGreet</span>(who) =&gt;
<span class="hljs-number">27</span>        greeting = message + <span class="hljs-string">", "</span> + who
</code></pre><p>此时</p><pre class="hljs"><code>message = <span class="hljs-string">"Howdy"</span>
who = <span class="hljs-string">"Akka"</span>
greeting = message + <span class="hljs-string">", "</span> + who = <span class="hljs-string">"Howdy, Akka"</span>
</code></pre><p>然后将 Greet 的消息传递给 <code>howdyGreeter</code>，这时会激活如下语句：</p><pre class="hljs"><code><span class="hljs-number">28</span>      <span class="hljs-keyword">case</span> <span class="hljs-type">Greet</span>           =&gt;
<span class="hljs-number">29</span>        <span class="hljs-comment">//#greeter-send-message</span>
<span class="hljs-number">30</span>        printerActor ! <span class="hljs-type">Greeting</span>(greeting)
<span class="hljs-number">31</span>        <span class="hljs-comment">//#greeter-send-message</span>
</code></pre><p>此时将 <code>Greet</code> 的消息通过 <code>Greeting</code> 传递给 <code>PrinterActor</code>。</p><p>最后 PrintActor 收到消息后，将消息打印在日志上。</p><pre class="hljs"><code><span class="hljs-number">51</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">receive</span> </span>= {
<span class="hljs-number">52</span>      <span class="hljs-keyword">case</span> <span class="hljs-type">Greeting</span>(greeting) =&gt;
<span class="hljs-number">53</span>        log.info(<span class="hljs-string">"Greeting received (from "</span> + sender() + <span class="hljs-string">"): "</span> + greeting)
<span class="hljs-number">54</span>    }
</code></pre><h3 id="思考">思考 <a class="markdownIt-Anchor" href="#思考">#</a></h3><p>如果我们多次输入 <code>reStrart</code> 来运行该例子，会发现输出的礼貌用语的次序各不相同。这就是说程序是并发执行的。同时需要注意，无论怎么执行，<code>howdyGreeter</code> 的两次结果，<code>Akka</code> 始终在 <code>Lightbend</code> 之前。我们可以得出结论：</p><ul><li>不同的 <code>Actor</code> 直接是并发执行的。</li><li>同一个 <code>Actor</code> 接收到的多个消息，是串行执行的。</li></ul><h1 id="参考文献">参考文献 <a class="markdownIt-Anchor" href="#参考文献">#</a></h1><p><a href="https://www.geeksforgeeks.org/scala-singleton-and-companion-objects/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/scala-singleton-and-companion-objects/</a></p><p><a href="https://www.tutorialspoint.com/scala/index.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/scala/index.htm</a></p><p><a href="https://www.runoob.com/scala/scala-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/scala/scala-tutorial.html</a></p><p><a href="https://blog.csdn.net/shenlei19911210/article/details/78538255" target="_blank" rel="noopener">https://blog.csdn.net/shenlei19911210/article/details/78538255</a></p><p><a href="https://docs.scala-lang.org/zh-cn/tour/pattern-matching.html" target="_blank" rel="noopener">https://docs.scala-lang.org/zh-cn/tour/pattern-matching.html</a></p><p><a href="https://developer.lightbend.com/guides/akka-quickstart-scala/" target="_blank" rel="noopener">https://developer.lightbend.com/guides/akka-quickstart-scala/</a></p></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="../../2019/kafka/index.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="../../2019/wxapp/index.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.14</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="../../2019/kafka/index.html">Kafka</a></li><ul class="chapter-level-2"><li class="chapter-item chapter-item-current"><a href="../../2019/kafka/2019-06-24-scala-simple-lesson.html">Scala 简明教程</a></li></ul><li class="chapter-item"><a href="../../2019/wxapp/index.html">小程序</a></li><ul class="chapter-level-2"><li class="chapter-item"><a href="../../2019/wxapp/2019-06-14-first_introduction.html">初识小程序</a></li><li class="chapter-item"><a href="../../2019/wxapp/2019-06-14-seconde_framework.html">小程序原理和开发框架介绍</a></li></ul></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"2019/kafka/2019-06-24-scala-simple-lesson.md",relative_root_path:"../../",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE">安装与配置</a>\n<ul>\n<li><a href="#%E5%AE%89%E8%A3%85-java">安装 Java</a></li>\n<li><a href="#%E5%AE%89%E8%A3%85-scala">安装 Scala</a></li>\n<li><a href="#%E5%AE%89%E8%A3%85-sbt">安装 sbt</a></li>\n</ul>\n</li>\n<li><a href="#hello-world">Hello World</a>\n<ul>\n<li><a href="#%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F">交互模式</a></li>\n<li><a href="#%E7%BC%96%E8%AF%91%E6%A8%A1%E5%BC%8F">编译模式</a></li>\n<li><a href="#%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%BC%8F">构建模式</a></li>\n</ul>\n</li>\n<li><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a></li>\n<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a>\n<ul>\n<li><a href="#%E6%95%B4%E6%95%B0">整数</a></li>\n<li><a href="#%E6%B5%AE%E7%82%B9%E6%95%B0">浮点数</a></li>\n<li><a href="#%E5%AD%97%E7%AC%A6">字符</a></li>\n<li><a href="#%E5%B8%83%E5%B0%94">布尔</a></li>\n<li><a href="#%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B">其它类型</a></li>\n<li><a href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F">变量与常量</a></li>\n</ul>\n</li>\n<li><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91">流程控制逻辑</a>\n<ul>\n<li><a href="#%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6">条件控制</a></li>\n<li><a href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6">循环控制</a></li>\n<li><a href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E7%9A%84-break-%E5%92%8C-continue">循环控制的 break 和 continue</a></li>\n</ul>\n</li>\n<li><a href="#%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90">一个例子</a></li>\n<li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a>\n<ul>\n<li><a href="#%E4%B8%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">主构造函数</a></li>\n<li><a href="#%E8%BE%85%E5%8A%A9%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">辅助构造函数</a></li>\n<li><a href="#singleton-objects">singleton objects</a></li>\n</ul>\n</li>\n<li><a href="#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1-companion-object">伴生对象 Companion Object</a></li>\n<li><a href="#%E7%BB%A7%E6%89%BF">继承</a>\n<ul>\n<li><a href="#override">override</a></li>\n<li><a href="#%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90-1">一个例子</a></li>\n</ul>\n</li>\n<li><a href="#%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90%EF%BC%88%E6%95%B4%E5%9E%8B%E6%95%B0%E5%80%BC%E5%8C%B9%E9%85%8D%E3%80%81%E6%B8%A9%E5%BA%A6%E5%88%A4%E6%96%AD%EF%BC%89">简单例子（整型数值匹配、温度判断）</a></li>\n<li><a href="#case-class">case class</a></li>\n<li><a href="#apply">apply</a></li>\n<li><a href="#unapply">unapply</a></li>\n<li><a href="#akka-hello-world">Akka Hello World</a></li>\n<li><a href="#akka-quickstart-with-scala">Akka Quickstart with Scala</a>\n<ul>\n<li><a href="#%E4%B8%8B%E8%BD%BD">下载</a></li>\n</ul>\n</li>\n<li><a href="#%E9%85%8D%E7%BD%AE%E5%8F%8A%E8%BF%90%E8%A1%8C">配置及运行</a>\n<ul>\n<li><a href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB">代码解读</a></li>\n<li><a href="#%E6%80%9D%E8%80%83">思考</a></li>\n</ul>\n</li>\n</ul>\n'}</script><script src="../../assets/js/app.js"></script></body></html>